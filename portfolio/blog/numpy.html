<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dena Burd: Blog</title>
    <link rel="stylesheet" href="../assets/prism.css" />
    <script src="../assets/prism.js"></script>
    <link rel="stylesheet" href="../style.css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.13.0/css/all.css"
        integrity="sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V" crossorigin="anonymous" />

</head>


<body>
    <div id='wrapper'>
        <div id="sidebar-wrapper">
            <!-- <a href="#" id="menu-toggle-off"><i class="fas fa-bars"></i></a> -->
            <div class='site-id' style="padding-top: 15vh;">
                <h1>DENA <strong>BURD</strong></h1>
                <h2>Software Engineer</h2>
            </div>
            <nav>
                <ul class="sidebar-nav navbar-nav flex-column text-sm-center">
                    <li><a href="../index.html#about">About</a></li>
                    <li><a href="../index.html#projects">Projects</a></li>
                    <li><a href="./posts.html">Blog</a></li>
                    <li><a href="#contact">Contact</a></li>
                </ul>
            </nav>
        </div>

        <div id='page-content-wrapper'>
            <div id="topbar-wrapper">
                <a style="float:left" href="../index.html">Dena Burd</a>
                <a href="#contact">Contact</a>
                <a href="./posts.html">Blog</a>
                <a href="../index.html#projects">Work</a>
                <a href="../index.html#about">About</a>
            </div>
            <header>
                <img class="post-image" src="../images/numpy2.png" alt=" post image">
            </header>
            <div class='container'>
                <h1 style="margin: 15px 0">Basic NumPy</h1>
                <p>Why use NumPy?</p>
                <p>NumPy (Numerical Python) is a multidimensional array python library. It's fast, open source and easy
                    to use! NumPy performs advanced computations on large data sets and simplifies working with arrays.
                </p>
                <p>The code for this post can be found on <a target="_blank"
                        href="https://github.com/gitburd/basic_numpy/blob/master/NumPy.ipynb"
                        rel="noopener noreferrer">github</a>.</p>
                <p>Before getting started <a target="_blank" href="https://numpy.org/install/"
                        rel="noopener noreferrer">Install NumPy with Conda or PIP </a>.</p>
                <p>To use the NumPy library it must be imported into a python file, Jupyter Notebook, repl, or other
                    development environment. </p>

                <pre><code class="language-python"> import numpy as np</code></pre>

                <h2 style="margin: 15px 0">1-D Arrays</h2>
                <p>Numpy arrays are used to store data of many types: integer, boolean, float, datetime, object, string,
                    and more. All data in single array must be the same type.
                </p>
                <p>To declare a NumPy array, pass a list to the <em>np.array</em> method.</p>

                <pre><code class="language-python">numbers = np.array([1,2,3])
mixed_type = np.array([True, "two", 3])</code></pre>

                <p>Select elements in a NumPy array with 0 index syntax, so the element in index 2 of both
                    <i>numbers</i> and <i>mixed_type</i> declared above is 3. However, a quick check shows that
                    mixed_type[2] is not equal to 3.
                </p>

                <pre><code class="language-python">print(numbers[2] == 3)
# => True
print(mixed_type[2] == 3)
# => False</code></pre>

                <p><i>dtype</i> is a property of the np.array that represents the data type. Checking the dtype of
                    mixed_type will explain why mixed_type[2] is not equal to 3.</p>

                <pre><code class="language-python">print(numbers.dtype)
# => int64
print(mixed_type.dtype)
# => &lt;U21</code></pre>

                <p>Since every element must have the same type, the boolean, string, and number in mixed_type have all
                    been converted to unicode strings.</p>

                <p>An array slice is defined by the syntax: <em>[start:stop:step].</em> A slice includes the interval
                    from [start, stop) incremented by step. ":" is the delimiter and alone represents "default". The
                    default values are start = 0, stop=len(array), and step=1.</p>
                <pre><code class="language-python">numbers = np.array([1,2,3,4,5])
print(numbers[3:])
# => [4 5]
print(numbers[1:4:])
# => [2 3 4]
print(numbers[::-2])
# => [5 3 1]</code></pre>

                <p>"3:" starts at index 3, and stops at len(numbers), stepping by 1.</p>
                <p>"1:4:" starts at index 1, and stops before index 4, stepping by 1.</p>
                <p>"::-2" steps backwards by 2 from len(numbers) to 0.</p>
                <h3 style="margin: 15px 0">1-D Manipulation</h3>
                <p>A single element or slice from an array can be selected and reassigned.</p>

                <pre><code class="language-python">numbers = np.array([1,2,3,4,5])
numbers[0] = 0 # element
print(numbers)
# => [0 2 3 4 5]
numbers[1:4] = [88,99,88] # slice
print(numbers)
# => [ 0 88 99 88  5]
numbers[::2] = 0 # all even indices
print(numbers)
# => [ 0 88  0 88  0]</code></pre>

                <p>The <i>append</i> method adds new elements to the end of an array. The <i>insert</i> method adds new
                    elements before a given index.</p>

                <pre><code class="language-python">numbers = np.array([1,2,3])

print(np.append(numbers,4))
# => [1 2 3 4]
print(np.append(numbers,[4,5,6]))
# => [1 2 3 4 5 6]

print(np.insert(numbers, 1, 9))
# => [1 9 2 3]
print(np.insert(numbers, 1, [9,9]))
# => [1 9 9 2 3]</code></pre>

                <p>The <i>delete</i> method removes elements from an array by index. To remove a particular value from
                    an array select elements that don't match it.</p>
                <pre><code class="language-python">numbers = np.array([0,1,2,3,4,5])

print(np.delete(numbers,3)) # remove by index
# => [0 1 2 4 5]
print(np.delete(numbers,[1,4,2]))
# => [0 3 5]

print(numbers[numbers != 2]) # remove by value
# => [0 1 3 4 5]</code></pre>

                <p>The methods <i>where</i> and <i>clip</i> can also be used to reassign values. np.where(condition,
                    value, array) replaces the elements in array matching condition with value. np.clip(array, min, max)
                    reassigns values in array above max to be max and below min to be min.</p>

                <pre><code class="language-python">numbers = np.array([1,2,3,7,8,9])

print(np.where(numbers > 7, 0, numbers))
# => [1 2 3 7 0 0]
print(np.clip(numbers,2,7))
# => [2 2 3 7 7 7]</code></pre>
                <p>Numpy can map elements in an array to True if they match a condition and False if it don't.</p>

                <pre><code class="language-python">numbers = np.array([1,2,3,7,8,9])
print(numbers > 3)
# => [False False False  True  True]</code></pre>

                <p>Assigning an array to be equal to another array means that they will point to the same spot in memory
                    and changing one will change the other. Use <i>copy</i> to build a new array with the current values
                    of another array.</p>

                <pre><code class="language-python">numbers = np.array([1,2,3,4,5])
numbers_b = numbers
numbers_copy = numbers.copy()
numbers[:3] = 0

print(numbers_b)
# => [0 0 0 4 5]
print(numbers_copy)
# => [1 2 3 4 5]</code></pre>
                <h2 style="margin: 15px 0">N-D Arrays</h2>
                <p>NumPy works with n-dimensional arrays and the syntax for declaring a 2-dimensional array is the same
                    as declaring a 1-dimensional array.</p>
                <pre><code class="language-python">matrix = np.array([[0,1,2],
[10,11,12], 
[20,21,22]])
print(matrix)
# => [[ 0  1  2]
#     [10 11 12]
#     [20 21 22]]</code></pre>

                <h3 style="margin: 15px 0">N-D Indexing</h3>
                <p>The syntax <em>array[row,col]</em> selects elements from a multidimensional array.The row and col can
                    be broken down into <em>start:stop:step</em> to select slices from the array.</p>

                <pre><code class="language-python">matrix = np.array([[0,1,2],
[10,11,12], 
[20,21,22]])
print(matrix[0,1]) # element
# => 1
print(matrix[0,:]) # row
# => [0 1 2]
print(matrix[:,2]) # col
# => [ 2 12 22]
print(matrix[0:2,0:2]) # slice
# => [[ 0  1]
#     [10 11]]
print(matrix[2::-1,2::-1]) # negative step
# => [[22 21 20]
#     [12 11 10]
#     [ 2  1  0]]</code></pre>

                <p>matrix[0,:] is the first row in matrix, the array [0,1,2]. The col is represented by ":" instead of
                    an index, so the element from every col in the row is selected.</p>
                <p>To select the third column, matrix[:2] takes the element from index 2 in every row.</p>
                <p>matrix[0:2,0:2] selects elements with a row and col of 0 or 1. It removes the 3rd row and 3rd col.
                </p>
                <p>matrix[2::-1][2::-1] starts at index 2 and steps backwards to 0 for both the row and col, inverting
                    the array.</p>
                <h3 style="margin: 15px 0">N-D Manipulation</h3>
                <p>Select elements a in multidimensional array to reassign their values.</p>

                <pre><code class="language-python">matrix = np.array([[0,1,2],
[10,11,12], 
[20,21,22]])
    # replace one element
    matrix[1,1] = 99
    print(matrix, "\n")
    # => [[ 0  1  2]
    #     [10 99 12]
    #     [20 21 22]] 

matrix[1,:] = [80,81,82] # replace every element in a row
print(matrix, "\n")
# => [[ 0  1  2]
#     [80 81 82]
#     [20 21 22]]

matrix[0::2,1] = 77 # replace even elements in a col
print(matrix)
# => [[ 0 77  2]
#     [80 81 82]
#     [20 77 22]]</code></pre>
                <p>np.concatenate can be used to add an array of the end of another array with the same dimensions if
                    the shapes are compatible.</p>
                <pre><code class="language-python">matrix = np.array([[0,1,2],
[10,11,12], 
[20,21,22]])
print(np.concatenate((matrix, 
                    [[30,31,32]])))
# => [[ 0  1  2]
#     [10 11 12]
#     [20 21 22]
#     [30 31 32]]</code></pre>

                <p>In this example both arrays are 2-dimensional. The arrays can be joined because the shapes are (3,3)
                    and (1,3), which have the same number of cols. A (2,2) or (3,1) array could not be appended to
                    matrix.</p>
                <p>np.where and np.clip can use the <em>array[row(start:stop:step), col(start:stop:step)]</em> slice
                    syntax to reassign selected values in multidimensional arrays.</p>


                <pre><code class="language-python">matrix = np.array([[0,1,2],
[10,11,12], 
[20,21,22]])
print(np.where(matrix % 3 == 0,
                0,
                matrix)) #where with every element
# => [[ 0  1  2]
#    [10 11  0]
#    [20  0 22]]
print(np.where(matrix[2] % 3 == 0,
                0, 
                matrix[2])) #where with one row
# => [20 21 21]

print(np.clip(matrix,8,18)) #clip with every element
# => [[ 8  8  8]
#    [10 11 12]
#    [18 18 18]]
print(np.clip(matrix[:,2],3,13)) #clip with one col
#=> [ 3 12 13]</code></pre>

                <p><i>vstack</i> and <i>hstack</i> are methods that add compatible size rows and cols to
                    multidimensional arrays.</p>
                <pre><code class="language-python">matrix = np.array([[0,1,2],
                [10,11,12], 
                [20,21,22]])
print(np.vstack([  # add rows
    matrix,
    [30,31,32], 
    [40,41,42]])) 
# => [[ 0  1  2]
#    [10 11 12]
#    [20 21 22]
#    [30 31 32]
#    [40 41 42]]
print(np.hstack([  # add cols
    matrix,
    [[3,4],
    [13,14],
    [23,24]
    ]]))
# => [[ 0  1  2  3  4]
#    [10 11 12 13 14]
#    [20 21 22 23 24]]</code></pre>

                <p>np.delete takes an array, an index and an axis as arguments for deleting an element.</p>

                <pre><code class="language-python">matrix = np.array([[0,1,2],
[10,11,12], 
[20,21,22]])

row_del = np.delete(matrix, 1, 0)
print(row_del)
# => [[ 0  1  2]
#     [20 21 22]]

col_del = np.delete(matrix, 1, 1)
print(col_del)
# => [[ 0  2]
#     [10 12]
#     [20 22]]</code></pre>

                <p><i>ndim</i> and <i>shape</i> can be used to get the dimensions and shape of an array. This example
                    shows how changing the deleted axis alters the dimensions and shape of the array.</p>

                <pre><code class="language-python">tensor = np.array([[[0,1],[10,11]],
[[20,21],[30,31]],
[[40,41], [50,51]]])
print(tensor.shape)
# => (3, 2, 2)
zero_del = np.delete(tensor, 1, 0)
print(zero_del, zero_del.shape)
# => [[[ 0  1]
#      [10 11]]
#     [[40 41]
#      [50 51]]] 
# shape (2, 2, 2)

one_del = np.delete(tensor, 1, 1)
print(one_del, one_del.shape)
# => [[[ 0  1]]
#     [[20 21]]
#     [[40 41]]] 
# shape (3, 1, 2)
    
two_del = np.delete(tensor, 1, 2)
print(two_del, two_del.shape)
# => [[[ 0]
#      [10]]
#     [[20]
#      [30]]
#     [[40]
#      [50]]] 
# shape (3, 2, 1)

print(zero_del.ndim, 
    one_del.ndim, 
    two_del.ndim)
# => 3 3 3</code></pre>
                <p>The original tensor shape was (3,2,2). So, deleting an index from the 0 axis returns a shape of
                    (2,2,2); deleting from the 1 axis returns (3,1,2); deleting from the 2 axis returns (3,2,1).
                    Deleting an index from each of these axis does not change the number of dimensions.</p>
                <p>reshape is a method to reorganize an array into a new shape with the same total number of indices. A
                    (3,4) array could be reshaped to (6,2) or (12,1) but not (7,2).</p>


                <pre><code class="language-python">array = np.array([[[0,1],[10,11]],
                [[20,21],[30,31]],
                [[40,41], [50,51]]])

print(array.reshape(3,4))
# => [[ 0  1 10 11]
#     [20 21 30 31]
#     [40 41 50 51]] 
print(array.reshape(2,2,1,3))
# => [[[[ 0  1 10]]
#      [[11 20 21]]]
#      [[[30 31 40]]
#       [[41 50 51]]]]
print(array.reshape(12))
# => [ 0  1 10 11 20 21 30 31 40 41 50 51]</code></pre>

                <h2 style="margin: 15px 0">Generators</h2>
                <p><i>zeros</i>, <i>ones</i>, and <i>full</i> are NumPy methods that construct arrays of given shape
                    with zeros, ones, and a specified value respectively. The default type of zeros and ones is a float,
                    but can be changed to an integer by passing a dtype to those methods. Full takes the shape and fill
                    value as arguments.</p>

                <pre><code class="language-python">zeros = np.zeros((2,3))
print(zeros)
# => [[0. 0. 0.]
#     [0. 0. 0.]] 
ones = np.ones((2,3,4), dtype="int8")
print(ones)
# => [[[1 1 1 1]
#      [1 1 1 1]
#      [1 1 1 1]]
#     [[1 1 1 1]
#      [1 1 1 1]
#      [1 1 1 1]]]             
threes =  np.full((2,2,2),3)
print(threes)
# => [[[3 3]
#      [3 3]]
#     [[3 3]
#      [3 3]]]
</code></pre>

                <p>NumPy's <a href="https://numpy.org/doc/stable/reference/random/generator.html#simple-random-data"
                        target="_blank" rel="noopener noreferrer">random</a> module is capable of generating seeded and
                    unseeded floats and integers.</p>
                <p>random.random is similar to zeros and ones, it takes the shape as an argument and constructs an array
                    of random floats in the interval [0.0, 1.0).</p>
                <p>random.randint take arguments start(inclusive) and stop(exclusive) for a range to draw random
                    integers from, and the keyword argument "size" for the shape. These numbers are random so the arrays
                    change every time the code runs.</p>


                <pre><code class="language-python">print(np.random.random((2,2,2)))
# => [[[0.14870216 0.90571043]
#      [0.99099023 0.46437422]]
#     [[0.9593967  0.11849078]
#      [0.13595443 0.47986692]]]
print(np.random.randint(
    -10,
    11, 
    size = (3,3)))
# => [[-2 -3 -7]
#     [10 -8  1]
#     [ 7  4 -2]]</code></pre>

                <p>np.rnadom.choice is a method that chooses random indices from an array. It can return a single index
                    or build an array of random indices based on the keyword argument "size". np.random.shuffle is a
                    method that rearranges the array elements in a random order.</p>
                <pre><code class="language-python">colors = np.array(["bumblebee", 
"cinnamon", 
"lava", 
"mahogany", 
"moss", 
"sapphire"])
print(np.random.choice(colors))
# => lava

print(np.random.choice(colors, size=(2,2)))
# => [['sapphire' 'moss']
#     ['cinnamon' 'bumblebee']]

np.random.shuffle(colors)
print(colors)
# => ['sapphire' 'lava' 'cinnamon' 'moss' 'bumblebee' 'mahogany']</code></pre>
                <h2 style="margin: 15px 0">Math</h2>
                <p>NumPy is extremely useful for mathematical computations. Basic PEMDAS operations, statistics, linear
                    algebra and calculus can all be performed on arrays. np.arange is a method that takes a start, stop
                    and step and builds an array of integers. When two arrays are added together, the value from
                    matching indices in each array is summed and returned. So, to preform a calculation with more than
                    one array the shapes must match.</p>
                <pre><code class="language-python">squares = np.array([1,4,9,16,25])
degrees = np.arange(-90, 135, 45) #every 45 between (-90,135]

print(degrees)
# => [-90 -45 0 45 90]
print(squares-13)
# => [-12  -9  -4   3  12]
print(squares * degrees)
# => [ -90 -180 0 720 2250]
print(np.cos(degrees))
# => [-0.44807362 0.52532199 1. 0.52532199 -0.44807362]</code></pre>

                <p>"squares * degrees" multiplies each index in squares by the corresponding index in degrees.</p>
                <p>np.max and np.min can find the max and min values for an array or an axis in an array.</p>

                <pre><code class="language-python">stats = [[-2, -3, -7],[10, -8,  1],[ 7,  4, -2]]
print(np.max(stats))
# => 10 
print(np.max(stats, axis = 0))
# => [10  4  1]
print(np.min(stats, axis = 1))
# => [-7 -8 -2] </code></pre>
                <p>NumPy has many more methods and advanced mathematical applications to discover. I hope this was a
                    useful introduction to getting started with NumPy basics. Thanks for reading :)</p>
            </div>
            <footer id="contact">
                <p style="margin:0 auto; text-align:center;">
                    <a target="_blank" href="https://github.com/gitburd"><i class="fab fa-github"></i></a>
                    <a target="_blank" href="https://www.linkedin.com/in/dena-burd/"><i
                            class="fab fa-linkedin-in fa-fw"></i></a>
                    <a target="_blank" href="mailto:denaburd@gmail.com"><i class="fas fa-envelope"></i></a>
                </p>
            </footer>
        </div>
    </div>
</body>

</html>